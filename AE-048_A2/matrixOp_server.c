/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "matrixOp.h"
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>

void printMatrix(int numberOfRows, int numberOfCols, float** matrix){

	for (int i = 0; i < numberOfRows; i++) {
        
        for (int j = 0; j < numberOfCols; j++) {

            printf("%f ",matrix[i][j]);
        }

		printf("\n");
    }

}

float** convertToMatrix(int numberOfRows, int numberOfCols, float* data){

	int currentIndex = 0;
	
	float** result = (float**)malloc(numberOfRows * sizeof(float*));
    for (int i = 0; i < numberOfRows; i++) {
        result[i] = (float*)malloc(numberOfCols * sizeof(float));
    }

	for(int i = 0; i < numberOfRows; i++){

		for(int j = 0; j < numberOfCols; j++){

			result[i][j] = data[currentIndex];
			currentIndex++;
			
		}
	}

	return result;
}

float** addMatrices(float** matrix1, float** matrix2, int numberOfRows, int numberOfCols) {
    
	float** result = (float**)malloc(numberOfRows * sizeof(float*));
    for (int i = 0; i < numberOfRows; i++) {
        result[i] = (float*)malloc(numberOfCols * sizeof(float));
    }

    for (int i = 0; i < numberOfRows; i++) {
        
        for (int j = 0; j < numberOfCols; j++) {

            result[i][j] = matrix1[i][j]+matrix2[i][j];
        }
    }
    return result;
}

float** multiplyMatrices(float** matrix1, float** matrix2, int numberOfRows1, int numberOfCols1, int numberOfCols2) {
    
	float** result = (float**)malloc(numberOfRows1 * sizeof(float*));
    for (int i = 0; i < numberOfRows1; i++) {
        result[i] = (float*)malloc(numberOfCols2 * sizeof(float));
    }

    for (int i = 0; i < numberOfRows1; i++) {
        
        for (int j = 0; j < numberOfCols2; j++) {
            
            for (int k = 0; k < numberOfCols1; k++) {
                
				result[i][j] += matrix1[i][k] * matrix2[k][j];
            
			}
        }
    }
    return result;
}

float** transposeMatrix(float** matrix, int numberOfRows, int numberOfCols) {
	
	float** result = (float**)malloc(numberOfCols * sizeof(float*));
    for (int i = 0; i < numberOfCols; i++) {
        result[i] = (float*)malloc(numberOfRows * sizeof(float));
    }

    for (int i = 0; i < numberOfCols; i++) {
        for (int j = 0; j < numberOfRows; j++) {
            result[i][j] = matrix[j][i];
        }
    }

	return result;
}

void getCofactor(float** matrix, float** temp, int p, int q,int n)
{
	int i = 0, j = 0;

	// Looping for each element of the matrix
	for (int row = 0; row < n; row++) {
		for (int col = 0; col < n; col++) {
			// Copying into temporary matrix only those
			// element which are not in given row and
			// column
			if (row != p && col != q) {
				temp[i][j++] = matrix[row][col];

				// Row is filled, so increase row index and
				// reset col index
				if (j == n - 1) {
					j = 0;
					i++;
				}
			}
		}
	}
}

	

float determinant(float** matrix, int dim)
{
	float det = 0; // Initialize result

	// Base case : if matrix contains single element
	if (dim == 1)
		return matrix[0][0];

	float** temp = (float**)malloc(dim * sizeof(float*));
    for (int i = 0; i < dim; i++) {
        temp[i] = (float*)malloc(dim * sizeof(float));
    }

	int sign = 1; // To store sign multiplier

	// Iterate for each element of first row
	for (int i = 0; i < dim; i++) {
		// Getting Cofactor of A[0][f]
		getCofactor(matrix, temp, 0, i, dim);
		det += sign * matrix[0][i] * determinant(temp, dim - 1);

		// terms are to be added with alternate sign
		sign = -sign;
	}

	return det;
}

void adjoint(float** matrix, float** adj, int dim)
{
	if (dim == 1) {
		adj[0][0] = 1;
		return;
	}

	// temp is used to store cofactors of A[][]
	int sign = 1;

	float** temp = (float**)malloc(dim * sizeof(float*));
    for (int i = 0; i < dim; i++) {
        temp[i] = (float*)malloc(dim * sizeof(float));
    }

	for (int i = 0; i < dim; i++) {
		for (int j = 0; j < dim; j++) {
			// Get cofactor of A[i][j]
			getCofactor(matrix, temp, i, j, dim);

			// sign of adj[j][i] positive if sum of row
			// and column indexes is even.
			sign = ((i + j) % 2 == 0) ? 1 : -1;

			// Interchanging rows and columns to get the
			// transpose of the cofactor matrix
			adj[j][i] = (sign) * (determinant(temp, dim - 1));
		}
	}
}

float** inverseMatrix(float** matrix,int dim)
{
	float** inv = (float**)malloc(dim * sizeof(float*));
    for (int i = 0; i < dim; i++) {
        inv[i] = (float*)malloc(dim * sizeof(float));
    }
	// Find determinant of A[][]
	float det = determinant(matrix, dim);
	
	// Find adjoint
	float** adj = (float**)malloc(dim * sizeof(float*));
    for (int i = 0; i < dim; i++) {
        adj[i] = (float*)malloc(dim * sizeof(float));
    }
	adjoint(matrix, adj, dim);

	// Find Inverse using formula "inverse(A) =
	// adj(A)/det(A)"
	for (int i = 0; i < dim; i++)
		for (int j = 0; j < dim; j++)
			inv[i][j] = adj[i][j] / det;

	return inv;
}

float* flattenMatrix(int numberOfRows, int numberOfCols, float** matrix){

	int totalElements = numberOfRows * numberOfCols;

    float* result = (float*)malloc(totalElements * sizeof(float));

	int currentIndex = 0;

	for(int i = 0; i < numberOfRows; i++){

		for(int j = 0; j < numberOfCols; j++){

			result[currentIndex] = matrix[i][j];
			currentIndex++;
		}
	}

	return result;
}

void copyArray(int length, float* src, float* dest){

	for(int i = 0; i < length; i++){

		dest[i] = src[i];
	}

	return;
}


Output *
add_1_svc(Input *argp, struct svc_req *rqstp)
{

	static Output  result;

	if(argp->numOfMatrices != 2 || argp->matrices[0].numOfRows != argp->matrices[1].numOfRows || argp->matrices[0].numOfCols != argp->matrices[1].numOfCols){
	
		strcpy(result.errorMessage , "Invalid Input");
		result.errorCode = 1;
		return (&result);
	}
	
	float** matrix1 = convertToMatrix(argp->matrices[0].numOfRows,argp->matrices[0].numOfCols,argp->matrices[0].data);
	
	float** matrix2 = convertToMatrix(argp->matrices[1].numOfRows,argp->matrices[1].numOfCols,argp->matrices[1].data);

	float** resultantMatrix = addMatrices(matrix1,matrix2,argp->matrices[0].numOfRows,argp->matrices[0].numOfCols);
	
	float* flattenedMatrix = flattenMatrix(argp->matrices[0].numOfRows,argp->matrices[0].numOfCols,resultantMatrix);

	copyArray(argp->matrices[0].numOfRows*argp->matrices[0].numOfCols,flattenedMatrix,result.result.data);

	result.result.numOfRows = argp->matrices[0].numOfRows;
	result.result.numOfCols = argp->matrices[0].numOfCols;
	result.errorCode = 0;
	
	return(&result);
}

Output *
multiply_1_svc(Input *argp, struct svc_req *rqstp)
{

	static Output  result;

	if(argp->numOfMatrices != 2 || argp->matrices[0].numOfCols != argp->matrices[1].numOfRows){
		
		strcpy(result.errorMessage , "Invalid Input");
		result.errorCode = 1;
		return (&result);
	}

	float** matrix1 = convertToMatrix(argp->matrices[0].numOfRows,argp->matrices[0].numOfCols,argp->matrices[0].data);
	
	float** matrix2 = convertToMatrix(argp->matrices[1].numOfRows,argp->matrices[1].numOfCols,argp->matrices[1].data);

	float** resultantMatrix = multiplyMatrices(matrix1,matrix2,argp->matrices[0].numOfRows,argp->matrices[0].numOfCols,argp->matrices[1].numOfCols);
	
	float* flattenedMatrix = flattenMatrix(argp->matrices[0].numOfRows,argp->matrices[1].numOfCols,resultantMatrix);

	copyArray(argp->matrices[0].numOfRows*argp->matrices[1].numOfCols,flattenedMatrix,result.result.data);

	result.result.numOfRows = argp->matrices[0].numOfRows;
	result.result.numOfCols = argp->matrices[1].numOfCols;
	result.errorCode = 0;

	return(&result);
}

Output *
inverse_1_svc(Input *argp, struct svc_req *rqstp)
{

	static Output  result;

	if(argp->numOfMatrices != 1 || argp->matrices[0].numOfRows != argp->matrices[0].numOfCols){
		
		strcpy(result.errorMessage , "Invalid Input");
		result.errorCode = 1;
		return (&result);
	}

	float** matrix = convertToMatrix(argp->matrices[0].numOfRows,argp->matrices[0].numOfCols,argp->matrices[0].data);

	float det = determinant(matrix,argp->matrices[0].numOfRows);

	if(det == 0){
		
		strcpy(result.errorMessage , "Singular Matrix");
		result.errorCode = 2;
		return (&result);

	}else{

		float** resultantMatrix = inverseMatrix(matrix,argp->matrices[0].numOfRows);
		float* flattenedMatrix = flattenMatrix(argp->matrices[0].numOfRows,argp->matrices[0].numOfCols,resultantMatrix);

		copyArray(argp->matrices[0].numOfRows*argp->matrices[0].numOfCols,flattenedMatrix,result.result.data);

		result.result.numOfRows = argp->matrices[0].numOfRows;
		result.result.numOfCols = argp->matrices[0].numOfCols;
		result.errorCode = 0;
	}

	
	return(&result);
}

Output *
transpose_1_svc(Input *argp, struct svc_req *rqstp)
{

	static Output  result;

	if(argp->numOfMatrices != 1){
		
		strcpy(result.errorMessage , "Invalid Input");
		result.errorCode = 1;
		return (&result);
	}

	float** matrix = convertToMatrix(argp->matrices[0].numOfRows,argp->matrices[0].numOfCols,argp->matrices[0].data);
	
	float** resultantMatrix = transposeMatrix(matrix,argp->matrices[0].numOfRows,argp->matrices[0].numOfCols);
	
	float* flattenedMatrix = flattenMatrix(argp->matrices[0].numOfCols,argp->matrices[0].numOfRows,resultantMatrix);

	copyArray(argp->matrices[0].numOfRows*argp->matrices[0].numOfCols,flattenedMatrix,result.result.data);

	result.result.numOfRows = argp->matrices[0].numOfCols;
	result.result.numOfCols = argp->matrices[0].numOfRows;
	result.errorCode = 0;

	return(&result);
}
